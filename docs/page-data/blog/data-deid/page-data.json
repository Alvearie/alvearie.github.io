{"componentChunkName":"component---src-pages-blog-data-deid-index-mdx","path":"/blog/data-deid/","result":{"pageContext":{"frontmatter":{"title":"Reduce the Risk of Subject Re-Identification Using the IBM Data De-Identification Server","description":"The Alvearie Data De-Identification server allows applications to strike the perfect balance between privacy and utility by providing a suite of utility-preserving masking providers"},"relativePagePath":"/blog/data-deid/index.mdx","titleType":"page","MdxNode":{"id":"eff6300f-042a-527e-994c-53a64ab5c16d","children":[],"parent":"a8e4ab42-5f5b-541f-a155-55ba5ddbe7fb","internal":{"content":"---\r\ntitle: Reduce the Risk of Subject Re-Identification Using the IBM Data De-Identification Server\r\ndescription: The Alvearie Data De-Identification server allows applications to strike the perfect balance between privacy and utility by providing a suite of utility-preserving masking providers\r\n---\r\nBy Denis Ricard &nbsp;&nbsp; | &nbsp;&nbsp; Published June 2, 2021\r\n\r\nOnce any information is digitized and secured using methods such as encryption, firewalls and authorization mechanisms, the next logical step is to \r\nmine the data to gain insight. However, before any personal data can be used to support secondary purposes, applicable privacy laws that govern this \r\npersonal data, such as HIPAA, GDPR, CCPA, PIPEDA, or others, must be understood and adhered to in addition to security requirements.\r\n\r\nPrimary Use of data is when usage of the data falls within the confines of the privacy law (as permitted use) and what the data subject consented to. \r\nIn Primary Use cases, it's best practice to pseudonymize direct identifiers (DI), which consist of fields that uniquely identify an individual on their \r\nown, unless the use case specifically requires the data subject to be identifiable. It is important to note that encrypting identifiers may not suffice \r\nto de-characterize data as non-personal because encrypted fields are still considered to be private information under some privacy legal frameworks.\r\n\r\nWhen source data are to be used for secondary purposes to the ones they were originally collected, they must first be de-identified or anonymized to a \r\npoint where the risk of re-identifying data subjects in the data is very low. Different privacy laws define different criteria and technologies on how \r\ndata must be processed to be sufficiently de-identified or anonymized. De-Identified or anonymized data typically falls outside the scope of the \r\ncorresponding privacy legal frameworks and can be more readily shared, combined and mined as it is no longer considered to be personal information. \r\n\r\nIn order to generate de-identified and anonymized data, in addition to the Direct Identifiers (DI) that may exist in the dataset, Quasi Identifiers \r\n(QI) - which consist of fields that, when combined with each other, can re-identify an individual - must also be protected. Adding quasi-identifying \r\nfields to a quasi-identifier progressively reduces the corresponding population that can be matched to an individual record and, therefore, increases \r\nthe probability of a successful re-identification attack. Protection of QI fields can be achieved through different means, such as via data value \r\ngeneralization or perturbation to prevent the combined QI fields in records from being associated with unique or few individuals.\r\n\r\n![Screen Shot](qi_examples.png)\r\n\r\n### Practical examples of re-identification protection\r\n\r\nEncrypted personal information (PI) is still considered PI under some privacy legal frameworks and encrypting field values makes it harder to use \r\nthe field for anything else than an equality predicate. As a result, even in privacy frameworks that allow encryption, this approach is not a good \r\nchoice when dealing with QI fields that must be used in various and complex computations. QI fields are typically valuable in data analyses as they \r\ninvolve demographics, geographic locations, event dates, etc., that are associated with individuals, so their privacy protection should be performed \r\nin a utility-preserving way. At the other end of the spectrum, redacting field values removes any utility from those fields and can break applications \r\nthat expect field data to be of a certain format.\r\n\r\n![Screen Shot](privacy_vs_utility.png)\r\n\r\nOur goal is to reduce the re-identification risk under a viable threshold while preserving data attributes that are interesting to \r\ndata scientists and algorithms that use the data. Let's take three specific examples to illustrate the point.\r\n\r\n### 1 - Zip Code\r\n\r\nHIPAA Safe Harbor has very specific requirements for US ZIP code handling. It allows to preserve the first 3 digits of the ZIP code but only if all \r\nZIP codes covered by these three digits have an aggregate population that is larger than 20,000 people, or else it must be replaced with 000. As of \r\nthe 2010 Census, 17 ZIP codes are restricted in such a way. With the Alvearie Data De-Identification server, the Safe Harbor requirement could be \r\nsatisfied with the following utility-preserving options:\r\n\r\n| Option  | Value  |\r\n| ---------|--------|\r\n| maskPrefixLength | 3 (default) |\r\n| maskPrefixRequireMinPopulation |\ttrue |\r\n| maskPrefixMinPopulation |\t20000 (default) |\r\n\r\nWhen using HIPAA Expert determination, other options could be considered at the discretion of the expert. For example, generalizing to the \r\nfirst 3 digits unless the minimum population requirement of 15,000 is not met in which case, generalize to 2 digits. In this scenario, the \r\nfollowing options would be used:\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| maskPrefixLength |\t3 |\r\n| maskTruncateIfNotMinPopulation |\tTrue |\r\n| maskPrefixMinPopulation |\t15000 |\r\n| maskTruncateLengthIfNotMinPopulation |\t2 |\r\n\r\nThe Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server allows the application of more than one data protection method to the same data element. This \r\napplies when multiple values are specified in the maskingProviders parameter of a rule. The data protection methods are applied in the \r\nsequence in which they are listed in the data de-identification configuration file. Here is an example that retrieves information about the \r\nstate where an individual resides for selected US states. Starting with a US postal (ZIP) code it translates five-digit codes to three digits \r\nand then maps the result to states ME, CT, and Other. This is achieved by chaining the ZIPCODE provider with the GENERALIZE provider.\r\n\r\n**ZIPCODE:** <br/>\r\nUse default options\r\n\r\n**GENERALIZE:**\r\n\r\n| Source Value   | Target Value  |\r\n| ---------|--------|\r\n| 040,041,042,043,044,045, 046,047,048,049 |\tME |\r\n| 060,061,062,063,064,065,066,067,068,069 |\tCT |\r\n| * |\tOther |\r\n\r\n### 2 - Birth date and Death date \r\n\r\nThere is a multitude of generalizations, perturbations, obfuscation and boundaries that can be imposed on dates, timestamps and durations. \r\nLet's consider a case where the birth date (/Patient/birthDate) of an individual should be masked for individuals who died at 5 years of age or \r\nless. Here are the possible DATEDEPENDENCY masking provider utility preservation options that would be used with the Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) \r\nserver to support such a case.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| dateYearDeleteNDaysValue |\t1825 (365*5) |\r\n| datetimeYearDeleteNIntervalCompareDate |\t/Patient/deceased |\r\n\r\nHere is a common example following the HIPAA Safe Harbor method where dates are generalized to year and ages over 89 must be categorized as \r\n90 years or older. With the Alvearie Data De-Identification server, supporting such a case simply requires these options to be used with the \r\nDATETIME masking provider on a birthdate field. Note that an option also exists to generalize to month and year instead of year only.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| generalizeYearMaskAgeOver90 |\tTrue |\r\n\r\n### 3 - Name\r\n\r\nName is a direct identifier and must be masked carefully. To maintain data utility with names, it is possible to replace names with fake names of the \r\nsame gender with a certain amount of accuracy. Depending on the privacy framework we are working under, it can also be possible to select a replacement \r\nname with pseudo-randomness so that we achieve consistent replacement of the name as we see it repeating in the original dataset. The pseudo-randomness \r\nfeature is not allowed in HIPAA Safe Harbor because the entire original value is hashed and used to select the pseudo-random feature. \r\nWith the Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server, the NAME masking provider would preserve gender for recognized given names with the \r\nfollowing options. Note that for localization purpose, files with new names can be added to the project and selected through property files.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| maskingAllowUnisex |\tfalse (default) |\r\n| maskPseudorandom |\tfalse (default) |\r\n| maskGenderPreserve |\ttrue |\r\n\r\nWith all the possible permutations, varying data sets, evolving schemas, new regions or countries to support, each with different privacy rules, \r\nhardcoding these rules within an application is not a viable long-term solution. Also, exposing coding interfaces to cover this amount of change \r\ncan be error-prone and problematic in healthcare-certified environments, where code changes require going over a costly verification and validation process. \r\n\r\n### Introducing the Alvearie Data De-Identification Server\r\n\r\nThe Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server allows applications to strike the perfect balance between privacy and utility by providing a suite of \r\nutility-preserving masking providers. The rich configuration schema allows applications to support privacy frameworks from different regions and \r\nadapt to various dataset schemas without changing the code itself. Since the application is built with healthcare in mind, it contains common rules \r\nthat experts tend to select. The generic masking providers also help to handle rare and unexpected data from other domains than healthcare.\r\n\r\n### Creating a masking configuration from what we learned earlier\r\n\r\nWe can use some of the masking configuration ideas from the previous section to create a configuration file that the Alvearie Data De-identification \r\nserver can use. The configuration has two main sections. The \"rules\" section defines masking rules using one of the supported masking providers \r\nalong with the desired options. In the \"json\" section that follows, input fields are assigned to one of the previously defined masking rules. \r\nThe \"json\" section also describes the schema of the input data as being FHIR records, and lists the supported resource type, which is \r\n\"Patient\" in this case. This resource type partitioning allows us to potentially define different masking rules for the same field as it appears \r\nin different resource types.\r\n\r\nThe masking configuration has a very rich set of features to allow solutions to strike the perfect balance between privacy and utility. \r\nRefer to the [Masking Configuration Overview](https://github.com/Alvearie/de-identification/blob/master/docs/masking-config-overview.md) for a more detailed look at masking configuration features such as \r\nJSON arrays, conditionals and internationalization support. \r\n\r\n```json\r\n{\r\n  \"rules\": [\r\n    {\r\n      \"name\": \"MaskZipCode\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"ZIPCODE\",\r\n          \"maskPrefixRequireMinPopulation\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskBirthDay\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"DATETIME\",\r\n          \"generalizeYearMaskAgeOver90\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskFirstName\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"NAME\",\r\n          \"maskGenderPreserve\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskFamilyName\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"NAME\"\r\n        }\r\n      ]\r\n    },    \r\n    {\r\n      \"name\": \"PHONE\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"PHONE\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"json\": {\r\n    \"schemaType\": \"FHIR\",\r\n    \"messageTypeKey\": \"resourceType\",\r\n    \"messageTypes\": [\r\n      \"Patient\"\r\n    ],\r\n    \"maskingRules\": [\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/name/given\",\r\n        \"rule\": \"MaskFirstName\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/name/family\",\r\n        \"rule\": \"MaskLastName\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/telecom/value\",\r\n        \"rule\": \"PHONE\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/birthDate\",\r\n        \"rule\": \"MaskBirthDay\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/address/postalCode\",\r\n        \"rule\": \"MaskZipCode\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### Using the Alvearie Data De-Identification Server\r\n\r\nThe fastest way to get started with the Alvearie Data De-Identification server is by using helm charts to deploy the server to a \r\nKubernetes cluster of your choice. The latest instructions are available on [GitHub](https://github.com/Alvearie/de-identification/blob/master/de-identification-app/chart/README.md).\r\n\r\n#### Pre-requisites\r\n \r\n - Kubernetes cluster 1.10+\r\n - Helm 3.0.0+\r\n - Jq 1.6+\r\n \r\n#### Check out the code and install the chart\r\n\r\n```\r\ngit clone https://github.com/Alvearie/de-identification.git\r\ncd de-identification/de-identification-app/chart\r\nhelm install deid .\r\n```\r\n\r\n#### Test the newly created service with original message text:\r\n\r\n```json\r\n{\r\n  \"resourceType\": \"Patient\",\r\n  \"id\": \"example\",\r\n  \"address\": {\r\n    \"postalCode\": \"10001\"\r\n  },\r\n  \"name\": [\r\n    {\r\n      \"use\": \"official\",\r\n      \"family\": \"Leroy\",\r\n      \"given\": [\r\n        \"Peter\",\r\n        \"James\"\r\n      ]\r\n    },\r\n    {\r\n      \"use\": \"usual\",\r\n      \"given\": [\r\n        \"Anna\"\r\n      ]\r\n    }\r\n  ],\r\n  \"telecom\": [\r\n    {\r\n      \"system\": \"phone\",\r\n      \"value\": \"+1-3471234567\",\r\n      \"use\": \"work\",\r\n      \"rank\": 1\r\n    }\r\n  ],\r\n  \"birthDate\": \"1974-12-25\"\r\n}\r\n```\r\n\r\n```\r\nkubectl port-forward service/deid 8888:8080&\r\n\r\ncurl -k POST --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{ \r\n\"config\":\"{\\\"rules\\\":[{\\\"name\\\":\\\"MaskZipCode\\\",\\\"maskingProviders\\\": [{\\\"type\\\":\\\"ZIPCODE\\\",\\\"maskPrefixRequireMinPopulation\\\":true}]},{\\\"name\\\":\\\"MaskBirthDay\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"DATETIME\\\",\\\"generalizeYearMaskAgeOver90\\\":true}]},{\\\"name\\\":\\\"MaskFirstName\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"NAME\\\",\\\"maskGenderPreserve\\\":true}]},{\\\"name\\\":\\\"MaskFamilyName\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"NAME\\\",\\\"maskPseudorandom\\\":true}]},{\\\"name\\\":\\\"PHONE\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"PHONE\\\"}]}],\\\"json\\\":{\\\"schemaType\\\":\\\"FHIR\\\",\\\"messageTypeKey\\\":\\\"resourceType\\\",\\\"messageTypes\\\":[\\\"Patient\\\"],\\\"maskingRules\\\":[{\\\"jsonPath\\\":\\\"/fhir/Patient/name/given\\\",\\\"rule\\\":\\\"MaskFirstName\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/name/family\\\",\\\"rule\\\":\\\"MaskFamilyName\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/address/postalCode\\\",\\\"rule\\\":\\\"MaskZipCode\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/telecom/value\\\",\\\"rule\\\":\\\"PHONE\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/birthDate\\\",\\\"rule\\\":\\\"MaskBirthDay\\\"}]}}\" , \"data\": [\"{\\\"resourceType\\\":\\\"Patient\\\",\\\"id\\\":\\\"example\\\",\\\"address\\\":{\\\"postalCode\\\":\\\"10001\\\"},\\\"name\\\":[{\\\"use\\\":\\\"official\\\",\\\"family\\\":\\\"Leroy\\\",\\\"given\\\":[\\\"Peter\\\",\\\"James\\\"]},{\\\"use\\\":\\\"usual\\\",\\\"given\\\":[\\\"Anna\\\"]}],\\\"telecom\\\":[{\\\"system\\\":\\\"phone\\\",\\\"value\\\":\\\"+1-3471234567\\\",\\\"use\\\":\\\"work\\\",\\\"rank\\\":1}],\\\"birthDate\\\":\\\"1974-12-25\\\"}\"], \"schemaType\": \"FHIR\" }' \\\r\n'http://localhost:8888/api/v1/deidentification' | jq \".\"\r\n```\r\n\r\n#### The output will look like this:\r\n\r\n```json\r\n{\r\n  \"data\": [\r\n    {\r\n      \"resourceType\": \"Patient\",\r\n      \"id\": \"example\",\r\n      \"address\": {\r\n        \"postalCode\": \"100\"\r\n      },\r\n      \"name\": [\r\n        {\r\n          \"use\": \"official\",\r\n          \"family\": \"Kole\",\r\n          \"given\": [\r\n            \"Jess\",\r\n            \"Jimmie\"\r\n          ]\r\n        },\r\n        {\r\n          \"use\": \"usual\",\r\n          \"given\": [\r\n            \"Gillian\"\r\n          ]\r\n        }\r\n      ],\r\n      \"telecom\": [\r\n        {\r\n          \"system\": \"phone\",\r\n          \"value\": \"+1-3475353644\",\r\n          \"use\": \"work\",\r\n          \"rank\": 1\r\n        }\r\n      ],\r\n      \"birthDate\": \"1974\"\r\n    }\r\n  ],\r\n  \"audit\": null\r\n}\r\n```\r\n\r\n#### Observations:\r\n\r\n - The postal code was reduced to three digits.\r\n - The first names have their gender preserved where it could be identified.\r\n - The family name is replaced with a consistent pseudo-random value.\r\n - The phone number has the country and area code preserved but other digits randomized so applications expecting the format to be valid will still work.\r\n - The birth date has been generalized to the year alone.\r\n\r\n### Typical Usage pattern\r\n\r\nTypically, the Alvearie De-Identification server is used after the raw input data has been consolidated so that input fields have a consistent and \r\nmeaningful value. The output data having the desired trade-off between privacy and usability is ready to mine. For cases where the schema is highly \r\nvariable and new fields with PI may suddenly appear, the \"defaultNoRuleResolution\" configuration parameter can be set to \"true\" so that any input \r\nfield without a specific rule association is nullified in the output. Create a rule that uses the MAINTAIN masking provider and assign it to any \r\nfield that must be sent through untouched.\r\n\r\n### Conclusion\r\n\r\nNow that you know the basics of data de-identification, you can expand on the configuration above to de-identify more resourceTypes. \r\nYou can also connect more components of the Alvearie project together as described in the [Clinical Data Ingestion Pattern](https://alvearie.io/blog/clinical-records-ingestion-pattern) blog.\r\n\r\n\r\n\r\n\r\n<p/>","type":"Mdx","contentDigest":"359f6a106b533940eafe99c9f01e8d41","counter":146,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Reduce the Risk of Subject Re-Identification Using the IBM Data De-Identification Server","description":"The Alvearie Data De-Identification server allows applications to strike the perfect balance between privacy and utility by providing a suite of utility-preserving masking providers"},"exports":{},"rawBody":"---\r\ntitle: Reduce the Risk of Subject Re-Identification Using the IBM Data De-Identification Server\r\ndescription: The Alvearie Data De-Identification server allows applications to strike the perfect balance between privacy and utility by providing a suite of utility-preserving masking providers\r\n---\r\nBy Denis Ricard &nbsp;&nbsp; | &nbsp;&nbsp; Published June 2, 2021\r\n\r\nOnce any information is digitized and secured using methods such as encryption, firewalls and authorization mechanisms, the next logical step is to \r\nmine the data to gain insight. However, before any personal data can be used to support secondary purposes, applicable privacy laws that govern this \r\npersonal data, such as HIPAA, GDPR, CCPA, PIPEDA, or others, must be understood and adhered to in addition to security requirements.\r\n\r\nPrimary Use of data is when usage of the data falls within the confines of the privacy law (as permitted use) and what the data subject consented to. \r\nIn Primary Use cases, it's best practice to pseudonymize direct identifiers (DI), which consist of fields that uniquely identify an individual on their \r\nown, unless the use case specifically requires the data subject to be identifiable. It is important to note that encrypting identifiers may not suffice \r\nto de-characterize data as non-personal because encrypted fields are still considered to be private information under some privacy legal frameworks.\r\n\r\nWhen source data are to be used for secondary purposes to the ones they were originally collected, they must first be de-identified or anonymized to a \r\npoint where the risk of re-identifying data subjects in the data is very low. Different privacy laws define different criteria and technologies on how \r\ndata must be processed to be sufficiently de-identified or anonymized. De-Identified or anonymized data typically falls outside the scope of the \r\ncorresponding privacy legal frameworks and can be more readily shared, combined and mined as it is no longer considered to be personal information. \r\n\r\nIn order to generate de-identified and anonymized data, in addition to the Direct Identifiers (DI) that may exist in the dataset, Quasi Identifiers \r\n(QI) - which consist of fields that, when combined with each other, can re-identify an individual - must also be protected. Adding quasi-identifying \r\nfields to a quasi-identifier progressively reduces the corresponding population that can be matched to an individual record and, therefore, increases \r\nthe probability of a successful re-identification attack. Protection of QI fields can be achieved through different means, such as via data value \r\ngeneralization or perturbation to prevent the combined QI fields in records from being associated with unique or few individuals.\r\n\r\n![Screen Shot](qi_examples.png)\r\n\r\n### Practical examples of re-identification protection\r\n\r\nEncrypted personal information (PI) is still considered PI under some privacy legal frameworks and encrypting field values makes it harder to use \r\nthe field for anything else than an equality predicate. As a result, even in privacy frameworks that allow encryption, this approach is not a good \r\nchoice when dealing with QI fields that must be used in various and complex computations. QI fields are typically valuable in data analyses as they \r\ninvolve demographics, geographic locations, event dates, etc., that are associated with individuals, so their privacy protection should be performed \r\nin a utility-preserving way. At the other end of the spectrum, redacting field values removes any utility from those fields and can break applications \r\nthat expect field data to be of a certain format.\r\n\r\n![Screen Shot](privacy_vs_utility.png)\r\n\r\nOur goal is to reduce the re-identification risk under a viable threshold while preserving data attributes that are interesting to \r\ndata scientists and algorithms that use the data. Let's take three specific examples to illustrate the point.\r\n\r\n### 1 - Zip Code\r\n\r\nHIPAA Safe Harbor has very specific requirements for US ZIP code handling. It allows to preserve the first 3 digits of the ZIP code but only if all \r\nZIP codes covered by these three digits have an aggregate population that is larger than 20,000 people, or else it must be replaced with 000. As of \r\nthe 2010 Census, 17 ZIP codes are restricted in such a way. With the Alvearie Data De-Identification server, the Safe Harbor requirement could be \r\nsatisfied with the following utility-preserving options:\r\n\r\n| Option  | Value  |\r\n| ---------|--------|\r\n| maskPrefixLength | 3 (default) |\r\n| maskPrefixRequireMinPopulation |\ttrue |\r\n| maskPrefixMinPopulation |\t20000 (default) |\r\n\r\nWhen using HIPAA Expert determination, other options could be considered at the discretion of the expert. For example, generalizing to the \r\nfirst 3 digits unless the minimum population requirement of 15,000 is not met in which case, generalize to 2 digits. In this scenario, the \r\nfollowing options would be used:\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| maskPrefixLength |\t3 |\r\n| maskTruncateIfNotMinPopulation |\tTrue |\r\n| maskPrefixMinPopulation |\t15000 |\r\n| maskTruncateLengthIfNotMinPopulation |\t2 |\r\n\r\nThe Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server allows the application of more than one data protection method to the same data element. This \r\napplies when multiple values are specified in the maskingProviders parameter of a rule. The data protection methods are applied in the \r\nsequence in which they are listed in the data de-identification configuration file. Here is an example that retrieves information about the \r\nstate where an individual resides for selected US states. Starting with a US postal (ZIP) code it translates five-digit codes to three digits \r\nand then maps the result to states ME, CT, and Other. This is achieved by chaining the ZIPCODE provider with the GENERALIZE provider.\r\n\r\n**ZIPCODE:** <br/>\r\nUse default options\r\n\r\n**GENERALIZE:**\r\n\r\n| Source Value   | Target Value  |\r\n| ---------|--------|\r\n| 040,041,042,043,044,045, 046,047,048,049 |\tME |\r\n| 060,061,062,063,064,065,066,067,068,069 |\tCT |\r\n| * |\tOther |\r\n\r\n### 2 - Birth date and Death date \r\n\r\nThere is a multitude of generalizations, perturbations, obfuscation and boundaries that can be imposed on dates, timestamps and durations. \r\nLet's consider a case where the birth date (/Patient/birthDate) of an individual should be masked for individuals who died at 5 years of age or \r\nless. Here are the possible DATEDEPENDENCY masking provider utility preservation options that would be used with the Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) \r\nserver to support such a case.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| dateYearDeleteNDaysValue |\t1825 (365*5) |\r\n| datetimeYearDeleteNIntervalCompareDate |\t/Patient/deceased |\r\n\r\nHere is a common example following the HIPAA Safe Harbor method where dates are generalized to year and ages over 89 must be categorized as \r\n90 years or older. With the Alvearie Data De-Identification server, supporting such a case simply requires these options to be used with the \r\nDATETIME masking provider on a birthdate field. Note that an option also exists to generalize to month and year instead of year only.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| generalizeYearMaskAgeOver90 |\tTrue |\r\n\r\n### 3 - Name\r\n\r\nName is a direct identifier and must be masked carefully. To maintain data utility with names, it is possible to replace names with fake names of the \r\nsame gender with a certain amount of accuracy. Depending on the privacy framework we are working under, it can also be possible to select a replacement \r\nname with pseudo-randomness so that we achieve consistent replacement of the name as we see it repeating in the original dataset. The pseudo-randomness \r\nfeature is not allowed in HIPAA Safe Harbor because the entire original value is hashed and used to select the pseudo-random feature. \r\nWith the Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server, the NAME masking provider would preserve gender for recognized given names with the \r\nfollowing options. Note that for localization purpose, files with new names can be added to the project and selected through property files.\r\n\r\n| Option   | Value  |\r\n| ---------|--------|\r\n| maskingAllowUnisex |\tfalse (default) |\r\n| maskPseudorandom |\tfalse (default) |\r\n| maskGenderPreserve |\ttrue |\r\n\r\nWith all the possible permutations, varying data sets, evolving schemas, new regions or countries to support, each with different privacy rules, \r\nhardcoding these rules within an application is not a viable long-term solution. Also, exposing coding interfaces to cover this amount of change \r\ncan be error-prone and problematic in healthcare-certified environments, where code changes require going over a costly verification and validation process. \r\n\r\n### Introducing the Alvearie Data De-Identification Server\r\n\r\nThe Alvearie [Data De-Identification](https://github.com/Alvearie/de-identification) server allows applications to strike the perfect balance between privacy and utility by providing a suite of \r\nutility-preserving masking providers. The rich configuration schema allows applications to support privacy frameworks from different regions and \r\nadapt to various dataset schemas without changing the code itself. Since the application is built with healthcare in mind, it contains common rules \r\nthat experts tend to select. The generic masking providers also help to handle rare and unexpected data from other domains than healthcare.\r\n\r\n### Creating a masking configuration from what we learned earlier\r\n\r\nWe can use some of the masking configuration ideas from the previous section to create a configuration file that the Alvearie Data De-identification \r\nserver can use. The configuration has two main sections. The \"rules\" section defines masking rules using one of the supported masking providers \r\nalong with the desired options. In the \"json\" section that follows, input fields are assigned to one of the previously defined masking rules. \r\nThe \"json\" section also describes the schema of the input data as being FHIR records, and lists the supported resource type, which is \r\n\"Patient\" in this case. This resource type partitioning allows us to potentially define different masking rules for the same field as it appears \r\nin different resource types.\r\n\r\nThe masking configuration has a very rich set of features to allow solutions to strike the perfect balance between privacy and utility. \r\nRefer to the [Masking Configuration Overview](https://github.com/Alvearie/de-identification/blob/master/docs/masking-config-overview.md) for a more detailed look at masking configuration features such as \r\nJSON arrays, conditionals and internationalization support. \r\n\r\n```json\r\n{\r\n  \"rules\": [\r\n    {\r\n      \"name\": \"MaskZipCode\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"ZIPCODE\",\r\n          \"maskPrefixRequireMinPopulation\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskBirthDay\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"DATETIME\",\r\n          \"generalizeYearMaskAgeOver90\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskFirstName\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"NAME\",\r\n          \"maskGenderPreserve\": true\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"MaskFamilyName\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"NAME\"\r\n        }\r\n      ]\r\n    },    \r\n    {\r\n      \"name\": \"PHONE\",\r\n      \"maskingProviders\": [\r\n        {\r\n          \"type\": \"PHONE\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"json\": {\r\n    \"schemaType\": \"FHIR\",\r\n    \"messageTypeKey\": \"resourceType\",\r\n    \"messageTypes\": [\r\n      \"Patient\"\r\n    ],\r\n    \"maskingRules\": [\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/name/given\",\r\n        \"rule\": \"MaskFirstName\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/name/family\",\r\n        \"rule\": \"MaskLastName\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/telecom/value\",\r\n        \"rule\": \"PHONE\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/birthDate\",\r\n        \"rule\": \"MaskBirthDay\"\r\n      },\r\n      {\r\n        \"jsonPath\": \"/fhir/Patient/address/postalCode\",\r\n        \"rule\": \"MaskZipCode\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### Using the Alvearie Data De-Identification Server\r\n\r\nThe fastest way to get started with the Alvearie Data De-Identification server is by using helm charts to deploy the server to a \r\nKubernetes cluster of your choice. The latest instructions are available on [GitHub](https://github.com/Alvearie/de-identification/blob/master/de-identification-app/chart/README.md).\r\n\r\n#### Pre-requisites\r\n \r\n - Kubernetes cluster 1.10+\r\n - Helm 3.0.0+\r\n - Jq 1.6+\r\n \r\n#### Check out the code and install the chart\r\n\r\n```\r\ngit clone https://github.com/Alvearie/de-identification.git\r\ncd de-identification/de-identification-app/chart\r\nhelm install deid .\r\n```\r\n\r\n#### Test the newly created service with original message text:\r\n\r\n```json\r\n{\r\n  \"resourceType\": \"Patient\",\r\n  \"id\": \"example\",\r\n  \"address\": {\r\n    \"postalCode\": \"10001\"\r\n  },\r\n  \"name\": [\r\n    {\r\n      \"use\": \"official\",\r\n      \"family\": \"Leroy\",\r\n      \"given\": [\r\n        \"Peter\",\r\n        \"James\"\r\n      ]\r\n    },\r\n    {\r\n      \"use\": \"usual\",\r\n      \"given\": [\r\n        \"Anna\"\r\n      ]\r\n    }\r\n  ],\r\n  \"telecom\": [\r\n    {\r\n      \"system\": \"phone\",\r\n      \"value\": \"+1-3471234567\",\r\n      \"use\": \"work\",\r\n      \"rank\": 1\r\n    }\r\n  ],\r\n  \"birthDate\": \"1974-12-25\"\r\n}\r\n```\r\n\r\n```\r\nkubectl port-forward service/deid 8888:8080&\r\n\r\ncurl -k POST --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{ \r\n\"config\":\"{\\\"rules\\\":[{\\\"name\\\":\\\"MaskZipCode\\\",\\\"maskingProviders\\\": [{\\\"type\\\":\\\"ZIPCODE\\\",\\\"maskPrefixRequireMinPopulation\\\":true}]},{\\\"name\\\":\\\"MaskBirthDay\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"DATETIME\\\",\\\"generalizeYearMaskAgeOver90\\\":true}]},{\\\"name\\\":\\\"MaskFirstName\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"NAME\\\",\\\"maskGenderPreserve\\\":true}]},{\\\"name\\\":\\\"MaskFamilyName\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"NAME\\\",\\\"maskPseudorandom\\\":true}]},{\\\"name\\\":\\\"PHONE\\\",\\\"maskingProviders\\\":[{\\\"type\\\":\\\"PHONE\\\"}]}],\\\"json\\\":{\\\"schemaType\\\":\\\"FHIR\\\",\\\"messageTypeKey\\\":\\\"resourceType\\\",\\\"messageTypes\\\":[\\\"Patient\\\"],\\\"maskingRules\\\":[{\\\"jsonPath\\\":\\\"/fhir/Patient/name/given\\\",\\\"rule\\\":\\\"MaskFirstName\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/name/family\\\",\\\"rule\\\":\\\"MaskFamilyName\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/address/postalCode\\\",\\\"rule\\\":\\\"MaskZipCode\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/telecom/value\\\",\\\"rule\\\":\\\"PHONE\\\"},{\\\"jsonPath\\\":\\\"/fhir/Patient/birthDate\\\",\\\"rule\\\":\\\"MaskBirthDay\\\"}]}}\" , \"data\": [\"{\\\"resourceType\\\":\\\"Patient\\\",\\\"id\\\":\\\"example\\\",\\\"address\\\":{\\\"postalCode\\\":\\\"10001\\\"},\\\"name\\\":[{\\\"use\\\":\\\"official\\\",\\\"family\\\":\\\"Leroy\\\",\\\"given\\\":[\\\"Peter\\\",\\\"James\\\"]},{\\\"use\\\":\\\"usual\\\",\\\"given\\\":[\\\"Anna\\\"]}],\\\"telecom\\\":[{\\\"system\\\":\\\"phone\\\",\\\"value\\\":\\\"+1-3471234567\\\",\\\"use\\\":\\\"work\\\",\\\"rank\\\":1}],\\\"birthDate\\\":\\\"1974-12-25\\\"}\"], \"schemaType\": \"FHIR\" }' \\\r\n'http://localhost:8888/api/v1/deidentification' | jq \".\"\r\n```\r\n\r\n#### The output will look like this:\r\n\r\n```json\r\n{\r\n  \"data\": [\r\n    {\r\n      \"resourceType\": \"Patient\",\r\n      \"id\": \"example\",\r\n      \"address\": {\r\n        \"postalCode\": \"100\"\r\n      },\r\n      \"name\": [\r\n        {\r\n          \"use\": \"official\",\r\n          \"family\": \"Kole\",\r\n          \"given\": [\r\n            \"Jess\",\r\n            \"Jimmie\"\r\n          ]\r\n        },\r\n        {\r\n          \"use\": \"usual\",\r\n          \"given\": [\r\n            \"Gillian\"\r\n          ]\r\n        }\r\n      ],\r\n      \"telecom\": [\r\n        {\r\n          \"system\": \"phone\",\r\n          \"value\": \"+1-3475353644\",\r\n          \"use\": \"work\",\r\n          \"rank\": 1\r\n        }\r\n      ],\r\n      \"birthDate\": \"1974\"\r\n    }\r\n  ],\r\n  \"audit\": null\r\n}\r\n```\r\n\r\n#### Observations:\r\n\r\n - The postal code was reduced to three digits.\r\n - The first names have their gender preserved where it could be identified.\r\n - The family name is replaced with a consistent pseudo-random value.\r\n - The phone number has the country and area code preserved but other digits randomized so applications expecting the format to be valid will still work.\r\n - The birth date has been generalized to the year alone.\r\n\r\n### Typical Usage pattern\r\n\r\nTypically, the Alvearie De-Identification server is used after the raw input data has been consolidated so that input fields have a consistent and \r\nmeaningful value. The output data having the desired trade-off between privacy and usability is ready to mine. For cases where the schema is highly \r\nvariable and new fields with PI may suddenly appear, the \"defaultNoRuleResolution\" configuration parameter can be set to \"true\" so that any input \r\nfield without a specific rule association is nullified in the output. Create a rule that uses the MAINTAIN masking provider and assign it to any \r\nfield that must be sent through untouched.\r\n\r\n### Conclusion\r\n\r\nNow that you know the basics of data de-identification, you can expand on the configuration above to de-identify more resourceTypes. \r\nYou can also connect more components of the Alvearie project together as described in the [Clinical Data Ingestion Pattern](https://alvearie.io/blog/clinical-records-ingestion-pattern) blog.\r\n\r\n\r\n\r\n\r\n<p/>","fileAbsolutePath":"C:/Alvearie/alvearie.github.io/src/pages/blog/data-deid/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3037994772","3037994772","768070550","768070550"]}